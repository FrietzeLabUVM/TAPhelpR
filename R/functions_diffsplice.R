get_wrap_script = function(){
  system.file("extdata/wrap_python.sh", package = "TAPhelpR", mustWork = TRUE)
}

#' suppa_joinFiles
#'
#' This must be run prior to [suppa_diffSplice] to group data by comparison
#' group.
#'
#' @param input_files Paths to either .bam files or .salmon_quant directories in
#'   a TAP output directory. See details for alternative formats and interaction
#'   with other parameters.
#' @param by Only used when input_files is a data.frame. Must be a character
#'   vector of attributes in input_files. Values of these attributes are used to
#'   split input_files into groups to join.
#' @param output_name File prefix for joinFiles outputs.
#' @param run_TPM If TRUE a joined tpm file will be generated. Default of TRUE.
#' @param PSI_todo Alternate splice event codes recognized by suppa2. See
#'   TAP_SPLICE_EVENTS global variable for possible values.
#' @param output_location Output location for joinFiles outputs. Will be created
#'   if it does not exist. Default is "suppa2_output".
#' @param bam_suffix Suffix that will be replaced in input_files to yield
#'   .salmon_quant directories.
#'
#' @details
#' `input_files` can be one of 3 formats.
#'
#' 1. A simple character vector of file paths. output_name is required in this case.
#' You'll need to call `suppa_joinFiles` multiple times in this scenario, once for
#' each comparison group.
#' 2. A named list of character vectors of file paths. List names will be used for
#' output_name of each entry. If your list contains all groups then a single
#' suppa_joinFiles call is sufficient.
#' 3. A data.frame where file paths are in "file" attribute or the first column.
#' The parameter `by` is required in this case but otherwise behaves similarly to
#' providing a list.
#'
#' @return The output location is invisibly returned.
#' @export
#'
#' @examples
#' work_dir = "/slipstream/home/dbgap/data/alignment_RNA-Seq/"
#' bam_files = find_bam_files(work_dir)
#' input_files = bam_files[1:5]
#' suppa_joinFiles(input_files, "test")
#'
#' suppa_joinFiles(bam_files[1:5], "test1")
#' suppa_joinFiles(bam_files[6:10], "test2")
suppa_joinFiles = function(input_files,
                           by = NULL,
                           output_name = NULL,
                           run_TPM = TRUE,
                           PSI_todo = unlist(SPLICE_EVENTS),
                           bam_suffix = ".Aligned.+",
                           joinFiles_output_location = "suppa2_output"){
  if(!all(PSI_todo %in% unlist(SPLICE_EVENTS))){
    stop(paste0("Some PSI_todo not recognized SPLICE_EVENTS: ", paste(setdiff(PSI_todo, unlist(SPLICE_EVENTS)), collapse = ", ")))
  }
  dir.create(joinFiles_output_location, showWarnings = FALSE, recursive = TRUE)
  if(is.data.frame(input_files)){
    if(is.null(by)){
      stop("'by' must be provided when supplying data.frame as input_files.")
    }
    if(!is.character(by)){
      stop("'by' must be a character.")
    }
    if(!all(by %in% colnames(input_files))){
      stop("elements of 'by' must in colnames input_files.")
    }
    if(length(by) > 1){
      new_groups = apply(as.data.frame(input_files)[, by], 1, function(x)paste(x, collapse = "_"))
    }else{
      new_groups = input_files[[by]]
    }
    if("file" %in% colnames(input_files)){
      message("Using values of 'file' attribute for joinFiles.")
      input_files = split(input_files[["file"]], new_groups)
    }else{
      message("Using first column '", colnames(input_files)[1], "'for input to joinFiles.")
      input_files = split(input_files[[1]], new_groups)
    }
  }
  if(is.list(input_files)){
    suppa_joinFiles.list(
      input_files = input_files,
      run_TPM = run_TPM,
      PSI_todo = PSI_todo,
      bam_suffix = bam_suffix,
      joinFiles_output_location = joinFiles_output_location
    )
  }else{
    if(all(grepl(".salmon_quant$", input_files))){
      message("Using specified .salmon_quant directories...")
    }else if(all(grepl("bam$", input_files))){
      message("Finding suppa files for bam input...")
      input_files = sub(bam_suffix, ".salmon_quant", input_files)
      if(any(!dir.exists(input_files))){
        stop("\nCould not convert bam file paths to .salmon_quant directories.",
             "\nVerify .salmon_quant is present with each .bam file in the same",
             " directory or supply .salmon_quant paths directly.")
      }
    }else{
      stop("Input files should specify either .bam files or .salmon_quant directories",
           " generated by the TAP pipeline.")
    }
    if(is.null(output_name)){
      stop("output_name was NULL but is required. output_name should be automatically",
           " generated unless input_files is a simple character vector.")
    }
    message("Running joinFiles...")
    if(run_TPM){
      message("tpm", "...")
      tpm_files = paste(file.path(input_files, "tpm.txt"), collapse = " ")
      out_file = file.path(joinFiles_output_location, paste0(output_name, ".tpm.tpm"))
      if(!file.exists(out_file)){
        cmd = paste0(TAP_SUPPA_PATH, " joinFiles -f tpm -i ", tpm_files, " -o ", sub(".tpm$", "", out_file))
        system(paste0("bash ", get_wrap_script(), " ", cmd))
      }else{
        message("Skipping ", out_file, " already exists.")
      }
    }
    for(psi in PSI_todo){
      message(psi, "...")
      psi_files = dir(input_files, pattern = paste0(psi, ".psi$"), full.names = TRUE)
      out_file = file.path(joinFiles_output_location, paste0(output_name, ".", psi, ".psi"))
      if(!file.exists(out_file)){
        cmd = paste0(TAP_SUPPA_PATH, " joinFiles -f psi -i ",
                     paste(psi_files, collapse = " "), " -o ", sub(".psi$", "", out_file))
        system(paste0("bash ", get_wrap_script(), " ", cmd))
      }else{
        message("Skipping joinFiles for ", out_file, ", output already exists.")
      }
    }
  }
  invisible(joinFiles_output_location)
}

suppa_joinFiles.list = function(input_files,
                                run_TPM = TRUE,
                                PSI_todo = unlist(SPLICE_EVENTS),
                                bam_suffix = ".Aligned.+",
                                joinFiles_output_location = "suppa2_output"){
  if(!is.list(input_files)){
    stop("suppa_joinFiles.list only accepts a list as input_files.")
  }
  for(name in names(input_files)){
    message(name)
    suppa_joinFiles(input_files[[name]],
                    output_name = name,
                    run_TPM = run_TPM,
                    PSI_todo = PSI_todo,
                    bam_suffix = bam_suffix,
                    joinFiles_output_location = joinFiles_output_location)
  }
}

get_tpm_files = function(work_dir){
  dir(work_dir, pattern = ".tpm$", full.names = TRUE)
}

get_psi_files = function(work_dir, psi){
  dir(work_dir, pattern = paste0(psi, ".psi$"), full.names = TRUE)
}

#' suppa_diffSplice
#'
#' Run after [suppa_joinFiles] to compare all groups. If this would result in an
#' undesirable number of uninteresting pairwise comparisons, consider using
#' [suppa_diffSplice.within_group] insead.
#'
#' @param joinFiles_output_location Working directory with output from [suppa_joinFiles]. Will be
#'   reused as diffSplice_output_location if not set.
#' @param ref_location Location of SUPPA2 directory in TAP reference.
#' @param PSI_todo Character vector of alternate events or isoform recognized by
#'   suppa2.  See variable SPLICE_EVENTS for valid values. Default will run all
#'   event types.
#' @param diffSplice_output_location Location to write output files to. Same as joinFiles_output_location if not
#'   specified.
#'
#' @return The output location is invisibly returned.
#' @export
#'
#' @examples
#' joinFiles_output_location = "suppa2_output"
#' ref_location = "~/indexes/HG38/SUPPA2"
#' suppa_diffSplice(joinFiles_output_location, ref_location)
suppa_diffSplice = function(
    ref_location,
    joinFiles_output_location = "suppa2_output",
    PSI_todo = unlist(SPLICE_EVENTS),
    diffSplice_output_location = joinFiles_output_location
){
  dir.create(diffSplice_output_location, recursive = TRUE, showWarnings = FALSE)
  for(psi in PSI_todo){
    message(psi, "...")
    tpm_files = get_tpm_files(joinFiles_output_location)
    psi_files = get_psi_files(joinFiles_output_location, psi)
    if(dir.exists(file.path(ref_location, "SUPPA2"))){
      ref_location = file.path(ref_location, "SUPPA2")
    }
    if(psi != "isoform"){
      ref_file = dir(ref_location, pattern = paste0(psi, ".+ioe"), full.names = TRUE)
    }else{
      ref_file = dir(ref_location, pattern = ".+ioi", full.names = TRUE)
    }
    out_root = file.path(diffSplice_output_location, paste0("diffSplice_result_", psi))
    if(!(file.exists(paste0(out_root, ".psivec")))){

      cmd = paste0(TAP_SUPPA_PATH, " diffSplice",
                   " -p ", paste(psi_files, collapse = " "),
                   " -e ", paste(tpm_files, collapse = " "),
                   " -i ", ref_file,
                   " -o ", out_root,
                   " -m empirical -a 1000 -l .05 -c")
      system(paste0("bash ", get_wrap_script(), " ", cmd))
    }else{
      message("Skipping diffSplice for ", out_root, ", output already exists.")
    }

  }
  invisible(diffSplice_output_location)
}

#' suppa_diffSplice.within_group
#'
#' @param input_files Paths to either .bam files or .salmon_quant directories in
#'   a TAP output directory. See details for alternative formats and interaction
#'   with other parameters.
#' @param by Only used when input_files is a data.frame. Must be a character
#'   vector of attributes in input_files. Values of these attributes are used to
#'   split input_files into groups to join.
#' @param joinFiles_output_location Working directory with output from [suppa_joinFiles]. Will be
#'   reused as diffSplice_output_location if not set.
#' @param ref_location Location of SUPPA2 directory in TAP reference.
#' @param PSI_todo Character vector of alternate events or isoform recognized by
#'   suppa2.  See variable SPLICE_EVENTS for valid values. Default will run all
#'   event types.
#' @param diffSplice_output_location Location to write output files to. Same as joinFiles_output_location if not
#'   specified.
#'
#' @return The output location is invisibly returned.
#' @export
#'
#' @examples
#' tap_out = "~/R_workspace.combined/TAPhelpR.data/honeybee_TAP_output"
#' bam_files = setup_bam_files(tap_out, var_map = c("day", "sex", "rep"))
#'
#' suppa_diffSplice.within_group(
#'   input_files = bam_files,
#'   within_group = "day",
#'   between_group = "sex",
#'   ref_location = "~/lab_shared/indexes/honeybee",
#'   PSI_todo = TAP_SPLICE_EVENTS$SkippingExon
#' )
suppa_diffSplice.within_group = function(
    input_files,
    within_group,
    between_group,
    ref_location,
    joinFiles_output_location = "suppa2_output",
    PSI_todo = unlist(SPLICE_EVENTS),
    diffSplice_output_location = joinFiles_output_location
){
  if(!is.character(within_group)){
    stop("'within_group' must be a character.")
  }
  if(!all(within_group %in% colnames(input_files))){
    stop("elements of 'within_group' must in colnames input_files.")
  }
  if(!is.character(between_group)){
    stop("'between_group' must be a character.")
  }
  if(!all(between_group %in% colnames(input_files))){
    stop("elements of 'between_group' must in colnames input_files.")
  }
  if(length(within_group) > 1){
    new_groups = apply(as.data.frame(input_files)[, within_group], 1, function(x)paste(x, collapse = "_"))
  }else{
    new_groups = input_files[[within_group]]
  }
  if(length(between_group) > 1){
    input_files$combo_group__ = apply(as.data.frame(input_files)[, between_group], 1, function(x)paste(x, collapse = "_"))
    between_group = "combo_group__"
  }

  if(!"file" %in% colnames(input_files)){
    message("Using first column '", colnames(input_files)[1], "'for input to joinFiles.")
    input_files$file = input_files[[1]]
  }

  input_files.sp = split(input_files, new_groups)
  sub_wd = file.path(diffSplice_output_location, within_group)
  grp = names(input_files.sp)[1]
  for(grp in names(input_files.sp)){
    stage_dir = file.path(sub_wd, grp)
    dir.create(stage_dir, showWarnings = FALSE, recursive = TRUE)
    sel_input_files = input_files.sp[[grp]]
    lapply(unique(sel_input_files[[between_group]]), function(nam){
      match_files = dir(joinFiles_output_location, pattern = paste0(nam, "\\."), full.names = TRUE)
      suppressWarnings({
        file.symlink(normalizePath(match_files), stage_dir)
      })
      match_files
    })
    suppa_diffSplice(
      joinFiles_output_location = stage_dir,
      ref_location = ref_location,
      PSI_todo = PSI_todo
    )
  }
  invisible(diffSplice_output_location)
}

#' suppa_clusterEvents
#'
#' @param diffSplice_output_location Working directory with output from suppa_joinFiles. Will be reused as output_location if not set.
#' @param PSI_todo Character vector of alternate events or isoform recognized by suppa2.  See variable SPLICE_EVENTS for valid values. Default will run all event types.
#' @param output_location Location to write output files to. Same as diffSplice_output_location if not specified.
#'
#' @return The output location is invisibly returned.
#' @export
#'
#' @examples
#' diffSplice_output_location = "suppa2_output"
#' suppa_clusterEvents(diffSplice_output_location)
suppa_clusterEvents = function(
    diffSplice_output_location = "suppa2_output",
    PSI_todo = unlist(SPLICE_EVENTS),
    output_location = diffSplice_output_location){
  dir.create(output_location, recursive = TRUE, showWarnings = FALSE)
  for(psi in PSI_todo){
    message(psi, "...")
    psivec_file = file.path(diffSplice_output_location, paste0("diffSplice_result_", psi, ".psivec"))
    stopifnot(file.exists(psivec_file))
    psivec_df.raw = read.table(psivec_file)


    all_dpsi_files = dir(diffSplice_output_location, pattern = paste0("diffSplice_result_", psi, "\\.dpsi"), full.names = TRUE)
    stopifnot(all(file.exists(all_dpsi_files)))
    for(dpsi_file in all_dpsi_files){
      dpsi_df.raw = read.table(dpsi_file, header = TRUE, row.names = 1)
      pair_str = sub("_dPSI", "", colnames(dpsi_df.raw)[1])
      message("  ", pair_str)
      pair_a = strsplit(pair_str, "\\.")[[1]][1]
      pair_b = strsplit(pair_str, "\\.")[[1]][2]

      psivec_df.dpsi_matched = psivec_df.raw[, grepl(pair_a, colnames(psivec_df.raw)) | grepl(pair_b, colnames(psivec_df.raw))]

      good_ids = rownames(dpsi_df.raw[!is.nan(dpsi_df.raw[[1]]),])
      psivec_df.dpsi_matched[good_ids,]

      dpsi_file.no_nan = paste0(sub(".dpsi", "", dpsi_file), ".", pair_a, ".", pair_b, ".no_nan.dpsi")
      psivec_file.no_nan = paste0(sub(".psivec", "", psivec_file), ".", pair_a, ".", pair_b, ".no_nan.psivec")


      write.table(dpsi_df.raw[good_ids,], dpsi_file.no_nan, sep = "\t", quote = FALSE)
      write.table(psivec_df.dpsi_matched[good_ids,], psivec_file.no_nan, sep = "\t", quote = FALSE)

      grps = sapply(strsplit(colnames(psivec_df.dpsi_matched), "_"), function(x){
        paste(x[-length(x)], collapse = "_")
      })

      ranges = sapply(unique(grps), function(x)range(which(x == grps)))
      groups_str = paste(paste(ranges[1,], ranges[2,], sep = "-"), collapse = ",")
      out_root = file.path(normalizePath(output_location), paste0("clusterEvents_result_", psi, ".", pair_a, ".", pair_b))

      if(!file.exists(paste0(out_root, ".clustvec"))){
        owd = getwd()
        setwd(dirname(dpsi_file.no_nan))
        cmd = paste0(TAP_SUPPA_PATH, " clusterEvents",
                     " --dpsi ", basename(dpsi_file.no_nan),
                     " --psivec ", basename(psivec_file.no_nan),
                     " --sig-threshold 0.1 --eps 0.05 --min-pts 20 ",
                     " --groups ", groups_str,
                     " -o ", out_root)
        message(cmd)
        system(paste0("bash ", get_wrap_script(), " ", cmd))
        setwd(owd)
      }else{
        message("Skipping clusterEvents for ", out_root, ", output already exists.")
      }
    }
  }
  invisible(output_location)
}


